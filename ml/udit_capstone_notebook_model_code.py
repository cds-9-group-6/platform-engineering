# -*- coding: utf-8 -*-
"""Udit_Capstone_Notebook_Model_Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qaYVebGd1b2xiyavXJ22YpSCr28OadsK
"""

!pip install keras
!pip install -U scikit-learn
!pip install tensorflow

import numpy as np
import cv2
from os import listdir
from sklearn.preprocessing import LabelBinarizer, MultiLabelBinarizer
from keras.models import Sequential
from keras.layers import BatchNormalization, Conv2D, MaxPooling2D, Activation, Flatten, Dropout, Dense
from keras import backend as K
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.utils import img_to_array
from tensorflow.keras.models import load_model # Import load_model
from keras.layers import Layer # Import Layer
import tensorflow as tf # Import tensorflow

from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

# Write a function that will take input as image file and return the model predicted label output and the probability of prediction as output

label_classes = ['Apple_scab', 'Bacterial_spot', 'Black_rot', 'Cedar_apple_rust',
 'Cercospora_leaf_spot Gray_leaf_spot', 'Common_rust', 'Early_blight',
 'Esca_(Black_Measles)' ,'Haunglongbing_(Citrus_greening)', 'Late_blight',
 'Leaf_Mold', 'Leaf_blight_(Isariopsis_Leaf_Spot)', 'Leaf_scorch',
 'Northern_Leaf_Blight', 'Powdery_mildew', 'Septoria_leaf_spot',
 'Spider_mites Two-spotted_spider_mite' ,'Target_Spot',
 'Tomato_Yellow_Leaf_Curl_Virus' ,'Tomato_mosaic_virus', 'Unknown', 'healthy']

def predict_leaf_classification(model,image_path, input_text="" ):
    """
    Predicts whether an image contains a leaf using the trained classification model.

    Args:
        image_path (str): The path to the input image file.
        model (keras.Model): The trained leaf classification model.

    Returns:
        tuple: A tuple containing the predicted class
               and the prediction probability (float).
               Returns (None, None) if the image cannot be loaded or model is not available.
    """
    if model is None:
        print("Error: Model is not loaded.")
        return None, None

    # Load the image
    image = cv2.imread(image_path)

    # Check if the image was loaded successfully
    if image is None:
        print(f"Error: Could not load image from {image_path}")
        return None, None

    target_size = (64, 64)

    # Resize the image to the target size expected by the model
    image_resized = cv2.resize(image, target_size)

    # Preprocess the image: convert to float32 and scale pixel values to [0, 1]
    image_preprocessed = image_resized.astype(np.float32) / 255.0

    # Add a batch dimension
    image_for_prediction = np.expand_dims(image_preprocessed, axis=0)

    # Make a prediction using the loaded model
    prediction = model.predict(image_for_prediction)

   # Get the index of the class with the highest probability
    predicted_class_index = np.argmax(prediction)

    print("idx=",predicted_class_index)
    # Get the predicted class label using the label binarizer
    predicted_class_label = label_classes[predicted_class_index]

    # Get the probability of the predicted class
    prediction_probability = prediction[0][predicted_class_index]

    return predicted_class_label, prediction_probability

# Create a custom Keras Layer for reshaping (needs to be defined for loading)
class ReshapeLayer(Layer):
    def __init__(self, target_shape, **kwargs):
        super(ReshapeLayer, self).__init__(**kwargs)
        self.target_shape = target_shape

    def call(self, inputs):
        return tf.reshape(inputs, self.target_shape)

    def get_config(self):
        config = super(ReshapeLayer, self).get_config()
        config.update({
            'target_shape': self.target_shape,
        })
        return config

# Define the path to the saved model (ensure this is correct)
model_save_path = '/content/leaf_classification_attention_cnn_model.h5'

# Load the model (if not already loaded)
print(f"[INFO] Loading leaf classification model from {model_save_path}...")
loaded_leaf_classification_model = load_model(model_save_path,custom_objects={'ReshapeLayer': ReshapeLayer})


# Example usage (assuming you have a test image at '/content/test_image.png')
# If the model was loaded successfully, you can call the function:
if loaded_leaf_classification_model is not None:
    test_image_path = '/content/test_image.JPG' # Replace with your test image path
    predicted_class, probability = predict_leaf_classification(loaded_leaf_classification_model,test_image_path)

    if predicted_class is not None:
        print(f"\nPrediction for {test_image_path}:")
        print(f"  Predicted Class: {predicted_class}")
        print(f"  Probability: {probability:.4f}")
    else:
        print("\nSkipping example usage because the model could not be loaded.")

# Write a function that will take input as image file and return the model predicted label output and the probability of prediction as output

def predict_leaf_presence(model,image_path, input_text="" ):
    """
    Predicts whether an image contains a leaf using the trained classification model.

    Args:
        image_path (str): The path to the input image file.
        model (keras.Model): The trained leaf classification model.

    Returns:
        tuple: A tuple containing the predicted class ('unknown' or 'with leaf')
               and the prediction probability (float).
               Returns (None, None) if the image cannot be loaded or model is not available.
    """
    if model is None:
        print("Error: Model is not loaded.")
        return None, None

    # Load the image
    image = cv2.imread(image_path)

    # Check if the image was loaded successfully
    if image is None:
        print(f"Error: Could not load image from {image_path}")
        return None, None

    target_size = (64, 64)

    # Resize the image to the target size expected by the model
    image_resized = cv2.resize(image, target_size)

    # Preprocess the image: convert to float32 and scale pixel values to [0, 1]
    image_preprocessed = image_resized.astype(np.float32) / 255.0

    # Add a batch dimension
    image_for_prediction = np.expand_dims(image_preprocessed, axis=0)

    # Make a prediction using the loaded model
    prediction = model.predict(image_for_prediction)

    # The output is a single probability value (since it's binary classification with sigmoid activation)
    # If the probability is > 0.5, we classify it as "with leaf", otherwise "unknown"
    prediction_probability = prediction[0][0]
    predicted_class = "with leaf" if prediction_probability > 0.5 else "unknown"


    return predicted_class, prediction_probability

# Define the path to the saved model
binary_model_path = '/content/leaf_binary_classification_model.h5'

# Load the model
print(f"[INFO] Loading binary leaf presence model from {binary_model_path}...")
loaded_leaf_presence_model = load_model(binary_model_path)
print("[INFO] Model loaded successfully.")


# Example usage (assuming you have a test image at '/content/test_image.png')
# If the model was loaded successfully, you can call the function:
if loaded_leaf_presence_model is not None:
    test_image_path = '/content/test_image.JPG' # Replace with your test image path
    predicted_class, probability = predict_leaf_presence(loaded_leaf_presence_model,test_image_path)

    if predicted_class is not None:
        print(f"\nPrediction for {test_image_path}:")
        print(f"  Predicted Class: {predicted_class}")
        print(f"  Probability: {probability:.4f}")
    else:
        print("\nSkipping example usage because the model could not be loaded.")

